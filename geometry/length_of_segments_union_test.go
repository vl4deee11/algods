package geometry

import (
	"sort"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Длина объединения отрезков на прямой.
// Даны N отрезков на прямой, т.е. каждый отрезок задаётся парой координат (X1, X2).
// Рассмотрим объединение этих отрезков и найдём его длину.

// segmentUnion - за O(NlogN)
// Положим все координаты концов отрезков в массив X и отсортируем его по значению координаты.
// Дополнительное условие при сортировке - при равенстве координат первыми должны идти левые концы.
// Кроме того, для каждого элемента массива будем хранить, относится он к левому или к правому концу отрезка.
// Теперь пройдёмся по всему массиву, имея счётчик C перекрывающихся отрезков.
// Если C отлично от нуля, то к результату добавляем разницу Xi - Xi-1.
// Если текущий элемент относится к левому концу, то увеличиваем счётчик C, иначе уменьшаем его.
func segmentUnion(segments [][2]int) int {
	// Слайс событий, где в индексе 0 - лежит точка на отрезке, в индексе 1 - лежит тип событие
	events := make([][2]int, 0, 2*len(segments))

	// Положим все отрезки в слайс событий
	for i := range segments {
		// 0 - начало отрезка, 2 - конец отрезка
		events = append(events, [2]int{segments[i][0], 0})
		events = append(events, [2]int{segments[i][1], 2})
	}

	// Отсортируем события
	sort.Slice(events, func(i, j int) bool {
		return events[i][0] <= events[j][0]
	})

	c := 0
	res := 0
	for i := range events {
		if c != 0 && i != 0 {
			res += events[i][0] - events[i-1][0]
		}
		if events[i][1] == 0 {
			// Реагируем на начало отрезка
			c++
		} else if events[i][1] == 2 {
			// Реагируем на конец отрезка
			c--
		}

	}
	return res
}

func TestSegmentUnion(t *testing.T) {
	res := segmentUnion([][2]int{{0, 5}, {5, 7}, {6, 9}, {13, 15}})
	assert.Equal(t, 11, res)
}
