package ds

import (
	"fmt"
	"math"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Разреженная таблица — структура данных, позволяющая отвечать на запросы минимума на отрезке за O(1) с препроцессингом
//за O(NlogN) времени и памяти.
// Разреженная таблица — это следующий двумерный массив размера logN*N
// t[k][i] = min(a_i, a_i+1, ... a_i+(2^k)-1) - считаем минимумы на отрезке длинны 2^k
// мы можем посчитать забирая данные из предыдуще вычисленных значений
// t[k][i] = min(t[k-1][i], t[k-1][i+2^(k-1)])
// Имея таком массив, мы можем для любого отрезка быстро посчитать минимум на нём.
// Заметим, что у любого отрезка имеется два отрезка длины степени двойки, которые пересекаются,
// и, главное, покрывают его и только его целиком.
// Доказательство:
// len - длинна отрезка
// Возьмем 2^k <= len, тут возможны два исхода если отрезок 2^k==len - все просто, они и будут пересекаться
// Если 2^k < len, пойдем от противного, если отрезки не пересекаются то получается что 2^k+2^k == 2^(k+1), но мы
// взяли 2^k изначально максимальное, что противоречит условию.
// Значит, мы можем просто взять минимум из значений, которые соответствуют этим отрезкам.
//
//         L                       R
// |----------------------------------------|
//         |      2^j      |
//                |       2^j      |

// Под таблицей здесь понимается таблица, в которой хранятся ответы на все возможные запросы поиска минимума на отрезке.
// То есть квадрат, в котором по вертикали отложены все возможные левые границы, а по горизонтали все возможные
// правые границы. Имея такую таблицу, можно без труда отвечать на запросы поиска минимума на отрезке просто
// обращаясь к соответствующим полям нашей таблицы.
// В этот момент мы решаем, что хранить всю таблицу мы не будем, а будем хранить разреженную таблицу.
// То есть сохраним значения не для всех возможных отрезков, а только для некоторых.
// Однако это должны быть такие отрезки, чтобы из ответов для них можно было сконструировать ответ для любого отрезка.
// В обычной таблице любой отрезок уже был предпосчитан.
// Такого мы себе позволить не можем, но давайте сделаем немного более слабое условие:
// должно выполняться условие, что любой отрезок массива можно накрыть двумя предпосчитанными отрезками.
// Тогда минимум на отрезке — это минимум из двух минимумов на этих подотрезках.
// При этом эти подотрезки могут пересекаться.
// В этот момент как раз таки мы и воспользуемся тем, что мы ищем именно минимум на отрезке, а не сумму.
// Если бы мы искали сумму, то нам было бы необходимо, чтобы подотрезки, на которые мы разбиваем наш отрезок,
// не пересекались, иначе пересечение мы учтем дважды.

// Разреженную таблицу можно применять не только для минимума или максимума.
// От операции требуется только ассоциативность (a∘(b∘c)=(a∘b)∘c),
// коммутативность (a∘b=b∘a) и идемпотентность (a∘a=a).
// Например, её можно применять для нахождения gcd
//

type sparseTable [][]int

// query - считает операцию на полуинтервале [l; r), за O(1)
func (t sparseTable) query(l, r int, op func(int, int) int) int {
	// Считаем в какой строке лежит наш отрезок, т.е наибольшее x, что бы 2^x подотрезок
	// пересекались если наложить 2 - подотрезка на отрезок
	x := int(math.Logb(float64(r - l)))
	// Один из полуинтервалов, на которые мы разбиваем, должен начинаться в левой границе,
	// а другой должен заканчиваться в правой, поэтому его левая граница, соответственно, должна быть на (1<<x) меньше
	// Например:
	//
	//         L                       R
	// |----------------------------------------|
	//     min(|      2^j      |,
	//                |       2^j      |)
	// Или если словами - мы берем два минимума на отрезке от l до l+(1<<x), и на отрезке от r-(1<<x) до r
	// И это и будет наш ответ
	return op(t[x][l], t[x][r-(1<<x)])
}

// Разберем на примере, пусть у нас есть массив: [1, 2, 1, 4, 3]
// ceil(logn(8)) = 3, считаем минимум на подотрезках длинны [1(k=0), 2(k=1), 4(k=2)]
// Таблица полученная будет:
// [1 2 1 4 3 5 2 3 1] = минимумы для длинны 1
// [1 1 1 3 3 2 2 1 0] = минимумы для длинны 2
// [1 1 1 2 2 1 0 0 0] = минимумы для длинны 4
//
// Обьяснение для минимума длинны 1 у нас уже все посчитано в arr[i],
// а для минимума длинны 2 мы считаем min(arr[i], arr[i+(1<<0)]) - т.е для i, i + 1
// а для длинны 4 мы считаем min(
//                             min(arr[i], arr[i+1<<0]),  - т.е для i, i + 1
//                             min(arr[i+(1<<1)], arr[i+(1<<1)+(1<<0)]), - т.е для i + 2, i + 2 + 1
//   						)
// Таким образом мы собираем эту таблицу и с низов, как дерево отрезков
func sparseTableBuild(arr []int, op func(int, int) int) sparseTable {
	l := len(arr)
	logn := int(math.Logb(float64(l)))
	t := make([][]int, logn)
	t[0] = arr
	for k := 0; k < logn-1; k++ {
		t[k+1] = make([]int, l)
		for i := 0; (i + (1 << k)) < l; i++ {
			t[k+1][i] = op(t[k][i], t[k][i+(1<<k)])
		}
	}
	return t
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func TestSparseTable(t *testing.T) {
	arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	tbl := sparseTableBuild(arr, min)
	assert.Equal(t, 1, tbl.query(0, 6, min))
	assert.Equal(t, 6, tbl.query(5, 7, min))

	arr = []int{1, 2, 1, 4, 3}
	tbl = sparseTableBuild(arr, min)
	assert.Equal(t, 1, tbl.query(0, 2, min))
	assert.Equal(t, 1, tbl.query(1, 3, min))

	arr = []int{1, 2, 1, 4, 3, 5, 2, 3, 1}
	tbl = sparseTableBuild(arr, min)
	for _, r := range tbl {
		fmt.Println(r)
	}
	assert.Equal(t, 1, tbl.query(0, 2, min))
	assert.Equal(t, 1, tbl.query(1, 3, min))

}
