package ds

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

// Рассмотрим какую-нибудь задачу на перебор подмножеств, которую мы умеем решать за O(X * poly(N))
// где poly(N) - полином от N. Метод meet-in-the-middle позволяет соптимизировать перебор до O((X/2) * poly(N))
// в большом классе таких задач. Если еще более абстрактно говорить, то метод meet-in-the-middle
// - способ оптимизации решений, заключающийся в
// том, чтобы разбить исходную задачу на две половины, решить каждую
// независимо и затем получить решение исходной задачи путем объединения решений половин.
// Соответсвено для применения данного паттерна алгоритма должны выполняться два условия.
// 1. Время, необходимое для решения половины задачи, асимптотически меньше времени решения целой задачи.
// 2. По решению задач-половин можно получить решений исходной целой задачи и при этом асимптотически быстрее,
// чем просто решить целую задачу.
// Для примера решим задачу: Задача о нахождении четырех чисел с суммой равной нулю
// Дан массив целых чисел A. Требуется найти любые 4 числа, сумма которых равна 0 (одинаковые элементы могут быть использованы несколько раз).
// Наивный алгоритм заключается в переборе всевозможных комбинаций чисел. Это решение работает за O(N^4), но мы
// сооптимизируем его до O(N^2)

func mitm(a []int) (int, int, int, int) {
	// sum — хэш карта сум a + b
	// Для оптимизации заметим что сумму a + b + c + d = 0, можно записать как a + b = -(c + d)
	sum := make(map[int][]int, len(a)*len(a))
	for i := 0; i < len(a); i++ {
		for j := 0; j < len(a); j++ {
			ab := a[i] + a[j]
			sum[ab] = append(sum[ab], i, j)
		}
	}

	for i := 0; i < len(a); i++ {
		for j := 0; j < len(a); j++ {
			cd := -(a[i] + a[j])
			if arr, ok := sum[cd]; ok {
				v := -1
				for k := range arr {
					if arr[k] != i {
						v = arr[k]
						break
					}
				}
				d := -1
				for k := range arr {
					if arr[k] != j && arr[k] != v {
						d = arr[k]
						break
					}
				}
				return v, d, i, j
			}
		}
	}

	return -1, -1, -1, -1
}

func TestMitm(t *testing.T) {
	arr := []int{2, 3, 1, 0, -4, -1}
	a, b, c, d := mitm(arr)
	assert.Equal(t, 0, arr[a]+arr[b]+arr[c]+arr[d])

	arr = []int{2, 3, 1, 0}
	a, b, c, d = mitm(arr)
	fmt.Println(a, b, c, d)
	assert.Equal(t, -1, a)
}
