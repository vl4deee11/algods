package ds

import (
	"sort"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Алгоритм заметающей прямой или алгоритм выметания плоскости — это алгоритмическая парадигма, которая использует умозрительную выметающую прямую или выметающую поверхность для решения различных задач в евклидовом пространстве.
// Это одна из ключевых техник в вычислительной геометрии.
//
// Идея алгоритмов этого типа заключается в представлении себе воображаемой прямой (чаще вертикальной), которая движется по плоскости, останавливаясь в некоторых точках.
// Геометрические операции ограничены геометрическими объектами, которые или пересекаются, или примыкают к выметающей прямой, а полное решение доступно, когда прямая пройдёт через все объекты.
// СМ: https://upload.wikimedia.org/wikipedia/commons/2/25/Fortunes-algorithm.gif

// scanLine - за время O(NlogN).
// Алогритм сканирующей прямой заключается в реагировании на событие начала и конца отрезка, так как только в этих
// точках случается изменение отрезка, а так же возможно реагировать в других точках, которые участвуют в алгоритме.
// В данном примере рассмотрим сканирующую прямую для поиска точки которая покрытая большим количеством отрезков.
func scanLine(segments [][2]int, points []int) int {
	// Слайс событий, где в индексе 0 - лежит точка на отрезке, в индексе 1 - лежит тип событие
	events := make([][2]int, 0, (2*len(segments))+len(points))

	// Положим все точки в слайс событий
	for i := range points {
		// 1 - появление точки
		events = append(events, [2]int{points[i], 1})
	}

	// Положим все отрезки в слайс событий
	for i := range segments {
		// 0 - начало отрезка, 2 - конец отрезка
		events = append(events, [2]int{segments[i][0], 0})
		events = append(events, [2]int{segments[i][1], 2})
	}

	// Отсортируем события
	sort.Slice(events, func(i, j int) bool {
		// Числа 0, 1, 2 - выбраны для типов событий неслучайно.
		// Это для того что бы отрезок у которого конец или начало совпадал с точкой,
		// был учтен в подсчете в точке
		if events[i][0] != events[j][0] {
			return events[i][0] < events[j][0]
		}
		return events[i][1] < events[j][1]
	})

	c := 0
	pm := -1
	pp := -1
	for i := range events {
		if events[i][1] == 0 {
			// Реагируем на начало отрезка
			c++
		} else if events[i][1] == 2 {
			// Реагируем на конец отрезка
			c--
		} else {
			// Реагируем на точку
			if pm < c {
				pm = c
				pp = events[i][0]
			}
		}

	}
	return pp
}

func TestScanLine(t *testing.T) {
	seq := [][2]int{{0, 5}, {1, 3}, {2, 3}, {5, 6}}
	//3                    .....
	//2        .....
	//1    .........
	//0.....................
	// 0   1   2   3   4   5   6
	pts := []int{2, 1, 0, 6, -1000}

	p := scanLine(seq, pts)
	assert.Equal(t, 2, p)
}
