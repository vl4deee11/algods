package math_x

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// Дана битовая маска m. Требуется эффективно перебрать все её подмаски, т.е.
// такие маски s, в которых могут быть включены только те биты, которые были включены в маске m.
// allSubMask - за время O(cnt(bm))
// Пусть у нас есть текущая подмаска s, и мы хотим перейти к следующей подмаске.
// Отнимем от маски s единицу, тем самым мы снимем самый правый единичный бит, а все биты правее него поставятся в 1.
// Затем удалим все "лишние" единичные биты, которые не входят в маску m и потому не могут входить в подмаску.
// Удаление осуществляется битовой операцией &bm.
// В результате мы "обрежем" маску s-1 до того наибольшего значения, которое она может принять,
// т.е. до следующей подмаски после s в порядке убывания.
//
// Таким образом, этот алгоритм генерирует все подмаски данной маски в порядке строгого убывания,
// затрачивая на каждый переход по две элементарные операции.
func allSubMask(bm int64) []int64 {
	r := make([]int64, 0)
	s := bm
	for s > 0 {
		r = append(r, s)
		s = (s - 1) & bm
	}

	return r
}

func TestAllSubMask(t *testing.T) {
	// 280 == "100011000"
	bm := int64(280)
	r := allSubMask(bm)
	assert.Equal(t, []int64{
		280,
		272,
		264,
		256,
		24,
		16,
		8,
	}, r)

	//100011000 280
	//100010000 272
	//100001000 264
	//100000000 256
	//000011000 24
	//000010000 16
	//000001000 8
}
