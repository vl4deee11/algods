package string

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

// Алгоритм Рабина-Карпа поиска подстроки в строке за O (N)
// Дана строка S и текст T, состоящие из маленьких латинских букв. Требуется найти все вхождения строки S в текст T за время O (|S| + |T|).
// Алгоритм. Посчитаем хэш для строки S. Посчитаем значения хэшей для всех префиксов строки T. Теперь переберём все подстроки T длины |S| и каждую сравним с |S| за время O (1)

// Один из лучших способов определить хэш-функцию от строки S следующий:
//
// h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N
// где P - некоторое число.
//
// Разумно выбирать для P простое число, примерно равное количеству символов во входном алфавите. Например,
// если строки предполагаются состоящими только из маленьких латинских букв, то хорошим выбором будет P = 31.
// Если буквы могут быть и заглавными, и маленькими, то, например, можно P = 53.
// Само значение хэша желательно хранить в самом большом числовом типе - int64.
// Очевидно, что при длине строки порядка 20 символов уже будет происходить переполнение значение.
// Ключевой момент - что мы не обращаем внимание на эти переполнения, как бы беря хэш по модулю 2^64.
func rabinKarp(t, s string) []int {
	// Тут работает только с алфавитом на маленьких, латинских буквах
	var p int64 = 31
	// Массив степеней p
	pPow := make([]int64, max(len(s), len(t)))
	pPow[0] = 1
	for i := 1; i < len(pPow); i++ {
		pPow[i] = pPow[i-1] * p
	}

	// Считаем хэши от всех префиксов строки T по функции h(S)
	h := make([]int64, len(t))
	for i := 0; i < len(t); i++ {

		h[i] = (int64(t[i]) - 'a' + 1) * pPow[i]
		if i > 0 {
			h[i] += h[i-1]
		}
	}

	// Считаем хэш от строки S по функции h(S)
	var hashS int64 = 0
	for i := 0; i < len(s); i++ {
		hashS += (int64(s[i]) - 'a' + 1) * pPow[i]
	}

	res := make([]int, 0)
	// перебираем все подстроки T длины |S| и сравниваем их
	for i := 0; i+len(s)-1 < len(t); i++ {
		// Хэш подстроки от 0 до i+len(s)-1
		currH := h[i+len(s)-1]
		if i > 0 {
			// Теперь получаем хэш подстроки от i до i+len(s)-1, через префикс сумму
			// H[I..J]  =  S[I]  +  S[I+1] * P  +  S[I+2] * P^2  +  ...  + S[J] * P^(J-I)
			// откуда:
			// H[I..J] * P[I]  =  S[I] * P[I]  +  ...  +  S[J] * P[J],
			// H[I..J] * P[I]  =  H[0..J]  -  H[0..I-1]
			// Полученное свойство является очень важным.
			//
			// Действительно, получается, что, зная только хэши от всех префиксов строки S,
			// мы можем за O (1) получить хэш любой подстроки.
			currH -= h[i-1]
		}

		// Единственная возникающая проблема - это то, что currH - здесь как раз хэш умноженный на i, то есть имеет смешение по i.
		// В большинстве случаев, вместо того чтобы делить хэши на степени P, можно, наоборот, умножать их на эти степени.
		// Допустим, даны два хэша: один умноженный на P[I], а другой - на P[J]. Если I < J, то умножим первый хэш на P[J-I],
		// иначе же умножим второй хэш на P[I-J].
		// Теперь мы привели хэши к одной степени (имеют одинаковое смещение по i), и можем их спокойно сравнивать.
		if currH == hashS*pPow[i] {
			res = append(res, i)
		}
	}
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func TestRabinKarp(t *testing.T) {
	text := "hellomydearfriendellogamello"
	s := "ello"
	ans := rabinKarp(text, s)
	assert.Equal(t, ans, []int{1, 17, 24})
}
