package tree

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

// Дерево Фенвика - это структура данных, дерево на массиве, обладающее следующими свойствами:
//
// 1. позволяет вычислять значение некоторой обратимой операции G на любом отрезке [L; R] за время O (log N);
// 2. позволяет изменять значение любого элемента за O (log N);
// 3. требует O (N) памяти, а точнее, ровно столько же, сколько и массив из N элементов;
// 4. легко обобщается на случай многомерных массивов.

// Дерево Фенвика можно использовать, когда наша операция обратима, а также когда трюк с префиксными суммами работает.
// Это обычно простые операции типа суммы, xor, умножения по модулю (если гарантируется, что на этот модуль ничего не делится).
// Минимум и gcd, отложенные операции и персистентность прикрутить в общем случае уже не получится — тогда уже нужно писать дерево отрезков.

// Для примера рассмотрим реализацию вычисления суммы на отрезке [L; R]

// Пусть дан массив A[0..N-1]. Деревом Фенвика будем называть массив  T[0..N-1], той же длины, объявленный следующим образом:
// T[i] = SUM значений A[i] от F(i) до i
// где F(i) - некоторая функция, для которой выполнено F(i) < i.
// Определим F(x) = (x & (x+1)); в коде fenwickTreeF
// Важное замечание 1:
// Любой префикс разбивается на O(logN) отрезков вида [F(i), i], а также что любой элемент входит в не более O(logN) таких отрезков.
//
//	16|   X-------------------------------------------X
//	8 |   X-------------------X
//	4 |   X-------X               X-------X
//	2 |   X--X        X--X        X--X        X--X
//	1 |   X     X     X     X     X     X     X     X
//
// len|
// _____________________________________________________
// _A[i]:1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16

// A = [1,2,3,4,5,6,7,8]
// s =  -               = 1 SUM(0,0)
// s =  - -             = 3 SUM(0,1)
// s =      -           = 3 SUM(2,2)
// s =  - - - -         = 10 SUM(0,3)
// s =          -       = 5  SUM(4,4)
// s =          - -     = 11 SUM(4,5)
// s =              -   = 7  SUM(6,6)
// a =  - - - - - - - - = 36 SUM(0,7)
// T = [1, 3, 3, 10, 5, 11, 7, 36]
// Отсюда видно, что все четные индексы входят в сумму один раз
// И видно что замечание Важное замечание 1 работает
func fenwickTreeF(x int) int {
	// Определим значение F(X) следующим образом.
	// Рассмотрим двоичную запись этого числа и посмотрим на его младший бит.
	// Если он равен нулю, то F(X) = X.
	// Иначе двоичное представление числа X оканчивается на группу из одной или нескольких единиц.
	// Заменим все единицы из этой группы на нули, и присвоим полученное число значению функции F(X).

	// Как пример рассмотрим x = 10011 (19)
	//   10011
	// & 10100
	//   10000 - заменили группу
	// Этому довольно сложному описанию соответствует очень простая формула:
	return x & (x + 1)
}

func fenwickTreeH(x int) int {
	// Как пример рассмотрим x = 10011 (19)
	//   10011
	// | 10100
	//   10111 - заменили группу
	return x | (x + 1)
}

// Для примера рассматриваем сумму
// fenwickTreeSum - сумма на отрезке [L, R] за O(logN)
// Когда нам нужна сумма на отрезке,
// мы будем сводить этот запрос к двум суммам на префиксе
func fenwickTreeSum(t []int, l, r int) int {
	// Тут все просто - префикс сумма
	return fenwickTreeOpT(t, r) - fenwickTreeOpT(t, l-1)
}

// fenwickTreeOpT операция на префиксе [0, R] за O(logN)
// операцию на префиксе будем считать так -> T[r] + fenwickTreeOpT(T, F(r) - 1)
func fenwickTreeOpT(t []int, r int) int {
	res := 0
	// Здесь итеративная реализация - T[r] + fenwickTreeOpT(T, F(r) - 1)

	// Функция fenwickTreeOpT работает следующим образом.
	// Вместо того чтобы идти по всем элементам массива A,
	// она движется по массиву T, делая "прыжки" через отрезки там, где это возможно.
	// Сначала она прибавляет к ответу значение суммы на отрезке [F(R); R],
	// затем берёт сумму на отрезке [F(F(R)-1); F(R)-1], и так далее, пока не дойдёт до нуля.

	for ; r >= 0; r = fenwickTreeF(r) - 1 {
		// Тут T[r] - значение дерева Фенвика (SUM значений A[r] от F(r) до r)
		// T[i] = A[F(i)] + A[F(i)+1] … + A[r]

		//  Или любая другая обратимая операции
		res += t[r]
	}
	return res
}

// fenwickTreeUpdT движется в обратную сторону
// в сторону увеличения индексов, обновляя значения суммы T[j] только для тех позиций, для которых это нужно,
// т.е. для всех j, для которых F(j) <= i <= j
// Мы будем изменять A[i] на величину delta. Тогда нам надо изменить элементы массива T[j], для которых верно неравенство F(j) <= i <= j
// Что это за числа, на самом деле? Такие, которые больше, чем наше i, но без последнего бита они уже меньше.
// Это значит, что все биты числа j, кроме последнего, встречаются в числе i. Кроме того, те биты,
// которые встречаются в i, но не встречаются в j, находятся правее последней единицы в j.
// То есть у i и j есть общий префикс битов, а потом в j стоят 10…00, а в i стоит 0, а потом что угодно.
func fenwickTreeUpdT(t *[]int, i, delta int) {
	j := i
	for ; j < len(*t); j = fenwickTreeH(j) {
		//  Или любая другая обратимая операции
		(*t)[j] += delta
	}
}

func TestFenwickTree(t *testing.T) {
	arr := []int{1, 2, 3, 4, 5, 6, 7, 8}
	//n := 8
	T := make([]int, len(arr))

	for i := range arr {
		fenwickTreeUpdT(&T, i, arr[i])
	}

	// 1. OpT 0 - n
	s1 := fenwickTreeSum(T, 0, 4)
	assert.Equal(t, s1, 15)
	// 2. OpT 0 - 0
	s2 := fenwickTreeSum(T, 0, 0)
	assert.Equal(t, s2, 1)
	// 3. OpT 2 - 4
	s3 := fenwickTreeSum(T, 2, 4)
	assert.Equal(t, s3, 12)

	// 4. Upd 3-> (3+8) = 11 & OpT 2 - 4
	fenwickTreeUpdT(&T, 2, 8)
	// arr := []int{1, 2, 11, 4, 5, 6, 7, 8}
	s4 := fenwickTreeSum(T, 2, 4)
	assert.Equal(t, s4, 20)
}
