package graph

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

//https://ru.algorithmica.org/cs/trees/centroid/

// Центроидная декомпозиция — обобщение метода «разделяй-и-властвуй» на деревья
//
// Центроидом дерева (англ. centroid) называется такая вершина v дерева t, после удаления которой
// дерево разбивается на несколько (k) поддеревьев t1,t2,…,tk, таких что для каждого i,
// выполняется условие |ti|<=(n/2), то есть размер каждого поддерева не превосходит половины размера исходного дерева.
//
//

// sizesT - за O(N) вычисляет размер для каждой вершины ее поддерева
// Здесь v - текущая вершина, gr - граф, sz - массив с размерами поддеревьев для вершин
func sizesT(v int, gr map[int][]int, sz []int) int {
	sz[v] = 1
	for _, nx := range gr[v] {
		// для простоты считаем, что дерево корневое
		sz[v] += sizesT(nx, gr, sz)
	}
	return sz[v]
}

// centroidT - за O(N) вычисляет центроид дерева
// Здесь v - текущая вершина, n - кол-во вершин в графе, gr - граф, sz - массив с размерами поддеревьев для вершин
func centroidT(v, n int, gr map[int][]int, sz []int) int {
	for _, nx := range gr[v] {

		// вернет вершину, у которой размеры всех детей не больше из за условия в if
		// так же мы можем быть уверены в том, что мы пришли в эту вершину когда у нее размер был больше n/2
		// значит в обратном направлении размер n - (n/2 + 1) = n/2 - 1
		// Иногда центроидов два (пример: 1-2-3-4), и тогда алгоритм вернёт «нижний» центроид
		if sz[nx] > n/2 {
			return centroidT(nx, n, gr, sz)
		}
	}
	return v
}

// Центроидной декомпозицией будем называть рекурсивный процесс «выделить центроид,
// удалить, запуститься от компонент».
// Компонентой центроида будем называть множество вершин, достижимых из центроида
// непосредственно перед его удалением.
//
// Заметим, что в конце всё дерево будет удалено, а значит каждая вершина ровно один раз побывала центроидом
// своей компоненты.
// Теперь поймём, зачем мы всё это делали.
//
// Утверждение. Каждая вершина входит в O(logn) компонент.
//
// Доказательство.
// Центроид разбивает дерево на компоненты в хотя бы два раза меньшего размера.
// Значит, никакая вершина не может «прожить» более ceil(log2n) разделений.
//
// Следствие. Центроидная декомпозиция (см. определение выше) работает за O(nlogn).
// Утверждение. Для любого пути a->b есть единственный центроид c, в чьей компоненте были и a и b
// Доказательство. Каждая вершина когда-то была центроидом.
// Какая-то из вершин на пути была центроидом первой, и она навсегда разъединила a и b
// Это очень важные выводы. Получается, что в процессе центроидной декомпозиции и для каждого простого пути будет
// ровно одна ситуация, когда этот путь содержится в какой-то компоненте и проходит через центроид.
// Ровно в этот момент мы можем обработать какой-то запрос, пользуясь техникой, похожей на метод переливаний.
// Рассмотрим задачу: Подсчет путей с заданным свойством
// Вмешаемся в процесс центроидной декомпозиции: для каждого центроида перед его удалением будем прибавлять к ответу
// число интересующих нас путей, которые проходят через этот центроид.

// sizes - за O(N) вычисляет размер для каждой вершины ее поддерева
func sizes(v, p int, gr map[int][]int, sz []int, used []bool) {
	sz[v] = 1
	for _, nx := range gr[v] {
		if nx == p || used[nx] {
			continue
		}
		// для простоты считаем, что дерево корневое
		sizes(nx, v, gr, sz, used)
		sz[v] += sz[nx]
	}
	return
}

// centroidT - за O(N) вычисляет центроид дерева
func centroid(v, p, n int, gr map[int][]int, sz []int, used []bool) int {
	for _, nx := range gr[v] {
		if nx == p || used[nx] {
			continue
		}

		if sz[nx] > n/2 {
			return centroid(nx, v, n, gr, sz, used)
		}
	}
	return v
}

// dfs - за O(N) записывает глубины вершин v
func dfs(v, p, d int, gr map[int][]int, used []bool, deeps *[]int) int {
	*deeps = append(*deeps, d)
	for _, nx := range gr[v] {
		if nx == p || used[nx] {
			continue
		}
		dfs(nx, v, d+1, gr, used, deeps)
	}
	return v
}

func solveCentroid(n int, targetLen int, gr map[int][]int) int {
	// не будем явно удалять вершины, заведем массив used - была ли вершина удалена
	used := make([]bool, n)
	sz := make([]int, n)
	return solve(0, n, targetLen, gr, used, sz)
}

// solve - за O(NlogN)
func solve(v, n, targetLen int, gr map[int][]int, used []bool, sz []int) int {
	/* <единственный зависящий от конкретной задачи код> */
	// Высчитаем размеры поддеревьев
	sizes(v, -1, gr, sz, used)
	// заведём мапу dist, в котором будем хранить количество вершин на каждом расстоянии от 0 до размера компоненты
	dist := map[int]int{0: 1}
	ans := 0
	// Подвесим наше дерево-компоненту за центроид и будем запускать от его непосредственных детей dfs,
	// который будет возвращать временный массив deeps — список глубин вершин в этом поддереве
	for _, nx := range gr[v] {
		if used[nx] {
			continue
		}
		deeps := make([]int, 0)
		dfs(nx, v, 1, gr, used, &deeps)
		// Мы можем пройтись по каждому значению x в нём и добавить к ответу dist[targetLen-x],
		// а затем добавить все значения из deeps в dist.
		// Можно убедиться, что таким образом каждый интересующий нас путь будет учтён ровно один раз.
		// Небольшие пояснения если например, мы ищем путь дилиной 5 и мы нашли глубину например 3 => до 5 нам не
		// хватает 2, и через dist[5-3] мы поймем сколькими путями мы можем построить путь дилины 2, если например
		// есть p1=2 и p2=2 - два пути то мы можем сделать пути 3+p1, 3+p2.
		// Тут как раз и обработаются перегибы
		for i := range deeps {
			if deeps[i] <= targetLen {
				ans += dist[targetLen-deeps[i]]
			}
		}
		// А тут просто запишем длинны путей которые мы нашли
		for i := range deeps {
			dist[deeps[i]]++
		}
	}
	/* <единственный зависящий от конкретной задачи код> */

	used[v] = true
	for _, nx := range gr[v] {
		if used[nx] {
			continue
		}
		// Найдем след центроид и подвесим дерево за него, таким образом мы найдем все матроиды
		// от наибольшего размера до наименьшего. И посчитаем пути и пути с перегибами
		c := centroid(nx, v, n, gr, sz, used)
		ans += solve(c, n, targetLen, gr, used, sz)
	}
	return ans
}

func TestSolveCentroid(t *testing.T) {
	gr := map[int][]int{
		0: {1, 2},
		1: {3, 4},
		2: {5, 6},
		3: {7},
	}

	//           0
	//       1        2
	//    3     4  5     6
	//  7

	a := solveCentroid(8, 4, gr)
	// p1. 7 - 3 - 1 - 0 - 2
	// p2. 3 - 1 - 0 - 2 - 5
	// p3. 3 - 1 - 0 - 2 - 6
	// p4. 4 - 1 - 0 - 2 - 6
	// p5. 4 - 1 - 0 - 2 - 5
	assert.Equal(t, 5, a)
	a = solveCentroid(8, 5, gr)
	// p1. 7 - 3 - 1 - 0 - 2 - 5
	// p2. 7 - 3 - 1 - 0 - 2 - 6
	assert.Equal(t, 2, a)
}
