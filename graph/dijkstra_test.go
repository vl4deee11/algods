package graph

import (
	"container/heap"
	"testing"

	"github.com/stretchr/testify/assert"
)

type MinHeap [][2]int

func (h MinHeap) Len() int            { return len(h) }
func (h MinHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }
func (h MinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *MinHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }
func (h *MinHeap) Pop() (v interface{}) {
	*h, v = (*h)[:len(*h)-1], (*h)[len(*h)-1]
	return
}

// Дан ориентированный или неориентированный взвешенный граф с n вершинами и m рёбрами.
// Веса всех рёбер неотрицательны. Указана некоторая стартовая вершина s.
// Требуется найти длины кратчайших путей из вершины s во все остальные вершины, а также предоставить способ вывода самих кратчайших путей.

//Основное утверждение, на котором основана корректность алгоритма Дейкстры, следующее.
// Утверждается, что после того как какая-либо вершина v становится помеченной, текущее расстояние до неё d[v] уже является кратчайшим,
// и, соответственно, больше меняться не будет.
//
// Доказательство будем производить по индукции. Для первой итерации справедливость его очевидна — для вершины s имеем d[s]=0,
// что и является длиной кратчайшего пути до неё.
// Пусть теперь это утверждение выполнено для всех предыдущих итераций, т.е. всех уже помеченных вершин.
// Докажем, что оно не нарушается после выполнения текущей итерации.
// Пусть v — вершина, выбранная на текущей итерации, т.е. вершина, которую алгоритм собирается пометить.
// Докажем, что d[v] действительно равно длине кратчайшего пути до неё (обозначим эту длину через l[v]).
//
// Рассмотрим кратчайший путь P до вершины v.
// Понятно, этот путь можно разбить на два пути: P_1, состоящий только из помеченных вершин (как минимум стартовая вершина s будет в этом пути),
// и остальная часть пути P_2 (она тоже может включать помеченные вершины, но начинается обязательно с непомеченной).
// Обозначим через p первую вершину пути P_2, а через q — последнюю вершины пути P_1.
//
// Докажем сначала наше утверждение для вершины p, т.е. докажем равенство d[p] = l[p].
// Однако это практически очевидно: ведь на одной из предыдущих итераций мы выбирали вершину q и выполняли релаксацию из неё.
// Поскольку (в силу самого выбора вершины p) кратчайший путь до p равен кратчайшему пути до q плюс ребро (q, p),
// то при выполнении релаксации из q величина d[p] действительно установится в требуемое значение.
//
// Вследствие неотрицательности стоимостей рёбер длина кратчайшего пути l[p]
// (а она по только что доказанному равна d[p]) не превосходит длины l[v] кратчайшего пути до вершины v.
// Учитывая, что l[v] <|= d[v] (ведь алгоритм Дейкстры не мог найти более короткого пути, чем это вообще возможно), в итоге получаем соотношения:
// d[p] = l[p] <|= l[v] <|= d[v]
//
// С другой стороны, поскольку и p, и v — вершины непомеченные, то так как на текущей итерации была выбрана именно вершина v, а не вершина p, то получаем другое неравенство:
//
// d[p] >|= d[v]
//
// Из этих двух неравенств заключаем равенство d[p] = d[v], а тогда из найденных до этого соотношений получаем и:
//
// d[v] = l[v]
//
//что и требовалось доказать.

// dijkstra - за O(M*logN)
// Здесь n - кол-во вершин в графе, st - стартовая вершина (откуда искать),
// edges - ребро, такое что edges[i][0] - вершина 1, edges[i][1] - вершина 2, edges[i][2] - вес (ребра не направленные)
func dijkstra(n int, st int, edges [][3]int) []int {
	graph := make(map[int][][2]int, n)
	for _, edge := range edges {
		u, v, w := edge[0], edge[1], edge[2]
		graph[u] = append(graph[u], [2]int{w, v})
		graph[v] = append(graph[v], [2]int{w, u})
	}

	inf := 1 << 31

	// Слайс расстояний от вершины st до всех остальных вершин
	dist := make([]int, n)
	for i := range dist {
		dist[i] = inf
	}
	dist[st] = 0
	// Инициализируем кучу
	h := &MinHeap{}
	heap.Init(h)
	h.Push([2]int{0, st})

	used := make([]bool, n)

	for h.Len() > 0 {
		e := heap.Pop(h).([2]int)
		// Если эту вершину уже посещали, нет смысла посещать ее второй раз
		if used[e[1]] {
			continue
		}
		used[e[1]] = true

		conns := graph[e[1]]
		for i := range conns {
			ne := conns[i]
			// Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a] + c.
			// Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a, b) и текущим ответом для вершины a.
			if dist[e[1]]+ne[0] < dist[ne[1]] {
				dist[ne[1]] = dist[e[1]] + ne[0]
				heap.Push(h, [2]int{dist[ne[1]], ne[1]})
			}
		}
	}
	return dist
}

func TestDijkstra(t *testing.T) {
	// Тестовый пример взял из https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif
	n := 6
	// 1 - 0
	// 2 - 1
	// 3 - 2
	// 4 - 3
	// 5 - 4
	// 6 - 5
	dist := dijkstra(n, 0, [][3]int{{0, 1, 7}, {1, 2, 10}, {1, 3, 15}, {2, 3, 11}, {0, 2, 9}, {0, 5, 14}, {3, 4, 6}, {2, 5, 2}, {5, 4, 9}})
	assert.Equal(t, []int{0, 7, 9, 20, 20, 11}, dist)
}
