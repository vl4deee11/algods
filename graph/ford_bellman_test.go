package graph

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Пусть дан ориентированный взвешенный граф G с n вершинами и m рёбрами, и указана некоторая вершина v.
// Требуется найти длины кратчайших путей от вершины v до всех остальных вершин.
// Этот алгоритм применим также и к графам, содержащим рёбра отрицательного веса.
// Впрочем, если граф содержит отрицательный цикл, то, понятно, кратчайшего пути до некоторых вершин может не существовать
// (по причине того, что вес кратчайшего пути должен быть равен минус бесконечности);
// впрочем, этот алгоритм можно модифицировать, чтобы он сигнализировал о наличии цикла отрицательного веса, или даже выводил сам этот цикл.
// В нашем случае просто будем выводить флаг наличия такого цикла

// fordBellman - за O(M*N)
// Здесь n - кол-во вершин в графе, st - стартовая вершина (откуда искать),
// edges - ребро, такое что edges[i][0] - вершина 1, edges[i][1] - вершина 2, edges[i][2] - вес (ребра направленные)
func fordBellman(n int, st int, edges [][3]int) (bool, []int, []int) {
	inf := 1 << 31

	// Слайс расстояний от вершины st до всех остальных вершин
	dist := make([]int, n)
	for i := 0; i < len(dist); i++ {
		dist[i] = inf
	}

	dist[st] = 0

	// Слайс родительских вершин в кратчайших путях
	parent := make([]int, n)
	for i := 0; i < len(parent); i++ {
		parent[i] = -1
	}

	// Сам алгоритм Форда-Беллмана представляет собой несколько фаз.
	// На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию (relax, ослабление)
	// вдоль каждого ребра (a, b) стоимости c.
	// Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a] + c.
	// Фактически это значит, что мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a, b) и текущим ответом для вершины a.
	//
	// Утверждается, что достаточно n-1 фазы алгоритма,
	// чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют).
	// Для недостижимых вершин расстояние d[] останется равным бесконечности inf.

	// Корректность работы: После выполнения i фаз алгоритм Форда-Беллмана корректно находит все кратчайшие пути,
	// длина которых (по числу рёбер) не превосходит i.

	// Доказательство => Рассмотрим произвольную вершину a, до которой существует путь из стартовой вершины v, и
	// рассмотрим кратчайший путь до неё: (p_0=v, p_1, ..., p_k=a).
	// Перед первой фазой кратчайший путь до вершины p_0=v найден корректно (так как dist[v]=0).
	// Во время первой фазы ребро (p_0, p_1) было просмотрено алгоритмом Форда-Беллмана,
	// следовательно, расстояние до вершины p_1 было корректно посчитано после первой фазы.
	// Повторяя эти утверждения k раз, получаем, что после k-й фазы расстояние до вершины p_k=a посчитано корректно, что и требовалось доказать.
	//
	// Последнее, что надо заметить — это то, что любой кратчайший путь не может иметь более n-1 ребра.
	// Следовательно, алгоритму достаточно произвести только n-1 фазу.
	// После этого ни одна релаксация гарантированно не может завершиться улучшением расстояния до какой-то вершины.
	for i := 0; i < n-1; i++ {
		f := false
		for j := range edges {
			if dist[edges[j][0]] < inf {
				nd := dist[edges[j][0]] + edges[j][2]
				if dist[edges[j][1]] > nd {
					dist[edges[j][1]] = nd
					parent[edges[j][1]] = edges[j][0]
					f = true
				}
			}
		}
		// Условие раннего выхода, если не смогли релаксировать больше ребер
		if !f {
			return true, dist, parent
		}
	}

	// Еще раз обрабатываем для проверки на отрицательные циклы
	for j := range edges {
		if dist[edges[j][0]] < inf {
			// Если можно еще раз сделать релаксацию => есть отрицательный цикл, так как должно хватить ровно n-1 попыток
			// для нахождения всех минимальных путей
			nd := dist[edges[j][0]] + edges[j][2]
			if dist[edges[j][1]] > nd {
				return false, dist, parent
			}
		}
	}
	return true, dist, parent
}

func TestFordBellman(t *testing.T) {
	// Тестовый пример взял из https://upload.wikimedia.org/wikipedia/commons/7/77/Bellman%E2%80%93Ford_algorithm_example.gif
	n := 5
	// s - 0
	// t - 1
	// x - 2
	// y - 3
	// z - 4
	ok, dist, pr := fordBellman(n, 0, [][3]int{{0, 1, 6}, {0, 3, 7}, {1, 2, 5}, {2, 1, -2}, {1, 4, -4}, {3, 2, -3}, {1, 3, 8}, {3, 4, 9}, {4, 0, 2}, {4, 2, 7}})
	fmt.Println(ok, dist, pr)
	assert.Equal(t, true, ok)
	assert.Equal(t, []int{0, 2, 4, 7, -2}, dist)
	assert.Equal(t, []int{-1, 2, 3, 0, 1}, pr)
}
