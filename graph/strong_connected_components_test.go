package graph

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// Дан ориентированный граф G, множество вершин которого V и множество рёбер — E. Петли и кратные рёбра допускаются.
// Обозначим через n количество вершин графа, через m — количество рёбер.
//
// Компонентой сильной связности (strongly connected component) называется такое (максимальное по включению) подмножество вершин C,
// что любые две вершины этого подмножества достижимы друг из друга, т.е. для все u,v в C
var orderSCC []int
var componentSCC []int
var uSCC []bool

// dfs1SCC - обычная топологическая сортировка по времени выхода из вершин
func dfs1SCC(v int, gr map[int][]int) {
	uSCC[v] = true
	for i := range gr[v] {
		nxv := gr[v][i]
		if !uSCC[nxv] {
			dfs1SCC(nxv, gr)
		}
	}
	orderSCC = append(orderSCC, v)
}

// dfs2SCC - собирает сильно связанную компоненту в слайс componentSCC
func dfs2SCC(v int, grT map[int][]int) {
	uSCC[v] = true
	componentSCC = append(componentSCC, v)
	for i := range grT[v] {
		nxv := grT[v][i]
		if !uSCC[nxv] {
			dfs2SCC(nxv, grT)
		}
	}
}

// strongConnectedComponents - за время O(n+m)
// Вход n - кол-во вершин в графе, edges - связи в графе из edges[i][0] -> edges[i][1]
func strongConnectedComponents(n int, edges [][2]int) [][]int {
	// Обычный граф
	gr := make(map[int][]int)
	// Транспонированный (обратный) граф
	grT := make(map[int][]int)

	// Массив флагов посещения вершин
	uSCC = make([]bool, n)

	for i := range edges {
		gr[edges[i][0]] = append(gr[edges[i][0]], edges[i][1])
		grT[edges[i][1]] = append(grT[edges[i][1]], edges[i][0])
	}

	// Первый шаг, отсортируем вершины топологической сортировкой (по времени выхода из вершины, TOUT[v])
	// и в этом порядке положим в orderSCC
	for i := 0; i < n; i++ {
		if !uSCC[i] {
			dfs1SCC(i, gr)
		}
	}

	//Теорема. Пусть C и C1 — две различные компоненты сильной связности,
	// и пусть в графе конденсации между ними есть ребро (C, C1).
	// Тогда TOUT[C] > TOUT[C1] => это означает что в слайсе orderSCC, все вершины C будут лежать после всех вершин C1
	//
	// При доказательстве возникает два принципиально различных случая в зависимости от того,
	// в какую из компонент первой зайдёт обход в глубину, т.е. в зависимости от соотношения между TIN[C] и TIN[C1]:
	//
	//1. Первой была достигнута компонента C. (в этом случае мы пройдем все вершины C1 и C).
	// Это означает, что в какой-то момент времени обход в глубину заходит в некоторую
	// вершину v компоненты C, при этом все остальные вершины компонент C и C1 ещё не посещены.
	// Но, т.к. по условию в графе конденсаций есть ребро (C, C1), то из вершины v будет достижима
	// не только вся компонента C, но и вся компонента C1. Это означает, что при запуске из вершины v обход в глубину пройдёт
	// по всем вершинам компонент C и C1, а, значит, они станут потомками по отношению к v в дереве обхода в глубину,
	// т.е. для любой вершины u в C И C1, u != v будет выполнено TOUT[v] > TOUT[u], ч.т.д.

	//2. Первой была достигнута компонента C1. (в этом случае мы пройдем все вершины только C1).
	// Опять же, в какой-то момент времени обход в глубину заходит в некоторую вершину v в C1,
	// причём все остальные вершины компонент C и C1 не посещены. Поскольку по условию в графе конденсаций
	// существовало ребро (C,C1), то, вследствие ацикличности графа конденсаций, не существует обратного пути
	// C1 в C, т.е. обход в глубину из вершины v не достигнет вершин C.
	// Это означает, что они будут посещены обходом в глубину позже, откуда и следует TOUT[C] > TOUT[C1], ч.т.д.

	uSCC = make([]bool, n)

	res := make([][]int, 0)
	for i := 0; i < n; i++ {
		// Тут самая суть алгоритма, мы идем по grT, и при этом берем все вершины в обратном порядке топологической сортировки.
		// Из Теоремы мы знаем что  TOUT[C] > TOUT[C1], даже если есть ребро мы его развернем в grT => из C мы достигнем только все
		// вершины компоненты С, и так как мы идем в обратном порядке => по ребру (C1, C) (обратное (C, C1)) мы не попадем в вершины C
		// при обработке вершины C1, так как они были посещены ранее
		v := orderSCC[n-1-i]
		if !uSCC[v] {
			dfs2SCC(v, grT)
			res = append(res, componentSCC)
			componentSCC = nil
		}
	}
	return res
}

func TestSCC(t *testing.T) {
	// Тестовый пример взял из https://upload.wikimedia.org/wikipedia/commons/e/e1/Scc-1.svg
	n := 8
	// a - 0
	// b - 1
	// .... и тд
	edges := [][2]int{
		{0, 1}, {1, 4}, {4, 0},

		{1, 2},

		{2, 3}, {3, 2}, {3, 7}, {7, 3},

		{7, 6},

		{6, 5}, {5, 6},
	}

	res := strongConnectedComponents(n, edges)
	assert.Equal(t, [][]int{{0, 4, 1}, {2, 3, 7}, {6, 5}}, res)
}
