package graph

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

const inf = 1<<63 - 1

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func maxflowBfs(s, t int, capacity [][]int) (int, []int) {
	// используется в функции maxflow для обратного пути
	parent := make([]int, len(capacity))
	for i := range parent {
		parent[i] = -1
	}

	q := newQueue()
	q.Enqueue([2]int{s, inf})

	for q.first != nil {
		x := q.Dequeue().([2]int)
		cur := x[0]
		flow := x[1]

		conns := capacity[cur]
		for i := range conns {
			next := i
			// Если еще не посещали и осталось пропускная способность
			if parent[next] == -1 && capacity[cur][next] > 0 {
				parent[next] = cur
				// Берем минимум из всего пути и текущего остатка, потому что мы не можем сделать поток больше чем
				// пропускная способность ребра, см: FLOW(edge[i]) <= CAPACITY(edge[i]).
				// То есть на всем пути поток - это минимум из остаточных пропускных способностей
				// всех ребер лежащих на пути
				newFlow := min(flow, capacity[cur][next])
				if next == t {
					return newFlow, parent
				}
				q.Enqueue([2]int{next, newFlow})
			}
		}
	}
	return 0, parent
}

// Пусть дан граф G, в котором выделены две вершины: исток S и сток T,
// а у каждого ребра определена пропускная способность Cu,v.
// Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку,
// если рассматривать граф как сеть труб с некоторыми пропускными способностями.
// Т.е. поток - функция Fu, v, определённая на множестве рёбер графа.
//
// Задача заключается в нахождении максимального потока.
// Хорошей аналогией для потоковой сети является следующая визуализация: мы представляем ребра в виде водопроводных труб,
// пропускная способность ребра — это максимальное количество воды, которое может пройти через трубу в секунду,
// а поток ребра — это количество воды которая в настоящее время проходит через трубу в секунду.
// Это мотивирует первое условие потока. По трубе не может пройти больше воды, чем ее вместимость.
// Вершины действуют как соединения, где вода выходит из одних труб, а затем эти вершины каким-то образом распределяют
// воду по другим трубам. Это также мотивирует второе условие потока.
// Вся поступающая вода должна распределяться по другим трубам в каждом соединении.
// Он не может волшебным образом исчезнуть или появиться. Источник S является источником всей воды,
// и вода может стекать только в раковину T.
// FLOW(edge[i]) <= CAPACITY(edge[i])
// SUM(for u, v in edges: FLOW([S, v])) == SUM(for u, v in edges: FLOW([v, T]))

// maxflow - за время O(V*E^2),
// s, t - исток, сток - соответственно, capacity - пропускная способность ребер
func maxflow(s, t int, capacity [][]int) int {
	flow := 0
	// Метод Форда-Фалкерсона работает следующим образом.
	// Во-первых, мы устанавливаем поток каждого ребра равным нулю.
	// Затем ищем увеличивающий путь из S в T. Дополняющий путь — это простой путь в остаточном графе, т. е. по ребрам,
	// остаточная пропускная способность которых положительна.
	// Если такой путь найден, то мы можем увеличить поток по этим ребрам.
	// Мы продолжаем искать увеличивающие пути и увеличивать поток.
	// Как только увеличивающий путь больше не существует, поток становится максимальным.
	for {
		// maxflowBfs - ищем bfs увеличивающий поток
		newFlow, parent := maxflowBfs(s, t, capacity)
		if newFlow == 0 {
			break
		}
		// Добавили в общий поток
		flow += newFlow
		// Идем обратно, уменьшая пропускную способность ребер в прямом порядке обхода
		// и увеличивая в обратном, таким образом мы некоторые ребра вообще как будто перекрываем,
		// и в постоянном поиске что же можно еще собрать из потока, в пути от S до T
		cur := t
		for cur != s {
			prev := parent[cur]
			capacity[prev][cur] -= newFlow
			capacity[cur][prev] += newFlow
			cur = prev
		}
	}

	return flow
}

func TestMaxFlow(t *testing.T) {
	S := 0
	T := 5
	capa := [][]int{
		{0, 7, 0, 0, 4, 0},
		{0, 0, 5, 3, 0, 0},
		{0, 0, 0, 0, 0, 8},
		{0, 0, 3, 0, 0, 5},
		{0, 3, 0, 2, 0, 0},
		{0, 0, 0, 0, 0, 0},
	}

	r := maxflow(S, T, capa)
	assert.Equal(t, 10, r)
}
